

===== src/main/java/com/example/urlshortener/infra/config/UndertowConfig.java =====

package com.example.urlshortener.infra.config;

import io.undertow.UndertowOptions;
import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.annotation.Configuration;

@Configuration
public class UndertowConfig implements WebServerFactoryCustomizer<UndertowServletWebServerFactory> {

    @Override
    public void customize(UndertowServletWebServerFactory factory) {
        factory.addBuilderCustomizers(builder -> {
            builder.setServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE, true);
            // Other tuning options can be added here if needed,
            // though many are handled via application.yml
        });
    }
}


===== src/main/java/com/example/urlshortener/infra/config/OpenApiConfig.java =====

package com.example.urlshortener.infra.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("High-Performance URL Shortener API")
                        .version("1.0.0")
                        .description("""
                                Ultra-fast URL shortening service built with:
                                - Java 21 Virtual Threads
                                - Spring Boot 3.5.7 + Undertow
                                - Apache Cassandra + Redis
                                - Bloom Filters & Multi-Level Caching

                                Designed to handle 100M+ writes/day and 1B+ reads/day.
                                """)
                        .contact(new Contact()
                                .name("API Support")
                                .url("https://github.com/seu-usuario/url-shortener")))
                .servers(List.of(
                        new Server().url("http://localhost:8080").description("Local Development")));
    }
}


===== src/main/java/com/example/urlshortener/infra/config/ShortCodeConfig.java =====

package com.example.urlshortener.infra.config;

import org.hashids.Hashids;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ShortCodeConfig {

    @Value("${app.shortener.salt}")
    private String salt;

    @Bean
    public Hashids hashids() {
        // MinLength 7 guarantees that even ID "1" generates something like "a1b2c3d"
        return new Hashids(salt, 7);
    }
}


===== src/main/java/com/example/urlshortener/infra/config/CassandraConfig.java =====

package com.example.urlshortener.infra.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.cassandra.config.AbstractCassandraConfiguration;
import org.springframework.data.cassandra.repository.config.EnableCassandraRepositories;
import org.springframework.data.cassandra.config.SchemaAction;

@Configuration
@EnableCassandraRepositories(basePackages = "com.example.urlshortener.infra.adapter.output.persistence")
public class CassandraConfig extends AbstractCassandraConfiguration {

    @Override
    protected String getKeyspaceName() {
        return "url_shortener";
    }

    @Override
    protected String getLocalDataCenter() {
        return "datacenter1";
    }

    @Override
    public String[] getEntityBasePackages() {
        return new String[] { "com.example.urlshortener.infra.adapter.output.persistence.entity" };
    }

    @Override
    public SchemaAction getSchemaAction() {
        return SchemaAction.CREATE_IF_NOT_EXISTS;
    }
}


===== src/main/java/com/example/urlshortener/infra/config/RedisConfig.java =====

package com.example.urlshortener.infra.config;

import org.redisson.api.RedissonClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.beans.factory.annotation.Value;

@Configuration
public class RedisConfig {

    @Bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }

}


===== src/main/java/com/example/urlshortener/infra/config/NativeHintsConfig.java =====

package com.example.urlshortener.infra.config;

import org.hashids.Hashids;
import org.springframework.aot.hint.MemberCategory;
import org.springframework.aot.hint.RuntimeHints;
import org.springframework.aot.hint.RuntimeHintsRegistrar;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportRuntimeHints;

@Configuration
@ImportRuntimeHints(NativeHintsConfig.HashidsHints.class)
public class NativeHintsConfig {

    static class HashidsHints implements RuntimeHintsRegistrar {
        @Override
        public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
            // Garante que o construtor e métodos da Hashids sobrevivam à compilação nativa
            hints.reflection().registerType(Hashids.class,
                    MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,
                    MemberCategory.INVOKE_PUBLIC_METHODS);
        }
    }
}


===== src/main/java/com/example/urlshortener/infra/Application.java =====

package com.example.urlshortener.infra;

import com.example.urlshortener.core.ports.incoming.ShortenUrlUseCase;
import com.example.urlshortener.core.ports.outgoing.IdGeneratorPort;
import com.example.urlshortener.core.ports.outgoing.MetricsPort;
import com.example.urlshortener.core.ports.outgoing.UrlRepositoryPort;
import com.example.urlshortener.core.service.UrlShortenerService;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@org.springframework.scheduling.annotation.EnableScheduling
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    public UrlShortenerService urlShortenerService(UrlRepositoryPort urlRepository, IdGeneratorPort idGenerator,
            com.example.urlshortener.core.ports.outgoing.UrlCachePort urlCache, MetricsPort metrics) {
        return new UrlShortenerService(urlRepository, idGenerator, urlCache, metrics);
    }
}


===== src/main/java/com/example/urlshortener/infra/observability/MetricsService.java =====

package com.example.urlshortener.infra.observability;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 * Service for tracking custom business metrics using Micrometer.
 * Provides methods to record URL shortening operations, cache performance,
 * and ID generation metrics.
 */
@Component
public class MetricsService {

    private final Counter urlsShortenedCounter;
    private final Counter cacheHitsCounter;
    private final Counter cacheMissesCounter;
    private final Counter bloomFilterRejectionsCounter;
    private final Timer idGenerationTimer;
    private final Timer urlRetrievalTimer;

    public MetricsService(MeterRegistry registry) {
        // URL Shortening Metrics
        this.urlsShortenedCounter = Counter.builder("urls.shortened.total")
                .description("Total number of URLs shortened")
                .tag("service", "url-shortener")
                .register(registry);

        // Cache Metrics
        this.cacheHitsCounter = Counter.builder("cache.hits.total")
                .description("Total number of cache hits")
                .tag("cache", "redis")
                .register(registry);

        this.cacheMissesCounter = Counter.builder("cache.misses.total")
                .description("Total number of cache misses")
                .tag("cache", "redis")
                .register(registry);

        this.bloomFilterRejectionsCounter = Counter.builder("bloomfilter.rejections.total")
                .description("Total number of requests rejected by Bloom Filter")
                .tag("protection", "cache-penetration")
                .register(registry);

        // Performance Timers
        this.idGenerationTimer = Timer.builder("id.generation.duration")
                .description("Time taken to generate a new ID")
                .tag("component", "id-generator")
                .register(registry);

        this.urlRetrievalTimer = Timer.builder("url.retrieval.duration")
                .description("Time taken to retrieve a URL")
                .tag("operation", "get")
                .register(registry);
    }

    /**
     * Record a URL shortening operation
     */
    public void recordUrlShortened() {
        urlsShortenedCounter.increment();
    }

    /**
     * Record a cache hit
     */
    public void recordCacheHit() {
        cacheHitsCounter.increment();
    }

    /**
     * Record a cache miss
     */
    public void recordCacheMiss() {
        cacheMissesCounter.increment();
    }

    /**
     * Record a Bloom Filter rejection (cache penetration protection)
     */
    public void recordBloomFilterRejection() {
        bloomFilterRejectionsCounter.increment();
    }

    /**
     * Record ID generation time
     */
    public void recordIdGeneration(long durationMs) {
        idGenerationTimer.record(durationMs, TimeUnit.MILLISECONDS);
    }

    /**
     * Record URL retrieval time
     */
    public void recordUrlRetrieval(long durationMs) {
        urlRetrievalTimer.record(durationMs, TimeUnit.MILLISECONDS);
    }

    /**
     * Execute and time an ID generation operation
     */
    public <T> T timeIdGeneration(java.util.function.Supplier<T> operation) {
        return idGenerationTimer.record(operation);
    }

    /**
     * Execute and time a URL retrieval operation
     */
    public <T> T timeUrlRetrieval(java.util.function.Supplier<T> operation) {
        return urlRetrievalTimer.record(operation);
    }
}


===== src/main/java/com/example/urlshortener/infra/observability/MicrometerMetricsAdapter.java =====

package com.example.urlshortener.infra.observability;

import com.example.urlshortener.core.ports.outgoing.MetricsPort;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Component;

/**
 * Adapter implementing MetricsPort using Micrometer.
 * Tracks business metrics for monitoring and observability.
 */
@Component
public class MicrometerMetricsAdapter implements MetricsPort {

    private final Counter urlsShortenedCounter;
    private final Counter cacheHitsCounter;
    private final Counter cacheMissesCounter;
    private final Counter bloomFilterRejectionsCounter;

    public MicrometerMetricsAdapter(MeterRegistry registry) {
        this.urlsShortenedCounter = Counter.builder("urls.shortened.total")
                .description("Total number of URLs shortened")
                .tag("service", "url-shortener")
                .register(registry);

        this.cacheHitsCounter = Counter.builder("cache.hits.total")
                .description("Total number of cache hits")
                .tag("cache", "redis")
                .register(registry);

        this.cacheMissesCounter = Counter.builder("cache.misses.total")
                .description("Total number of cache misses")
                .tag("cache", "redis")
                .register(registry);

        this.bloomFilterRejectionsCounter = Counter.builder("bloomfilter.rejections.total")
                .description("Total number of requests rejected by Bloom Filter")
                .tag("protection", "cache-penetration")
                .register(registry);
    }

    @Override
    public void recordUrlShortened() {
        urlsShortenedCounter.increment();
    }

    @Override
    public void recordCacheHit() {
        cacheHitsCounter.increment();
    }

    @Override
    public void recordCacheMiss() {
        cacheMissesCounter.increment();
    }

    @Override
    public void recordBloomFilterRejection() {
        bloomFilterRejectionsCounter.increment();
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/redis/RedisUrlCache.java =====

package com.example.urlshortener.infra.adapter.output.redis;

import com.example.urlshortener.core.ports.outgoing.MetricsPort;
import com.example.urlshortener.core.ports.outgoing.UrlCachePort;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

@Component
public class RedisUrlCache implements UrlCachePort {

    private final StringRedisTemplate redisTemplate;
    private final RedissonClient redisson;
    private final Cache<String, String> localCache;
    private final RBloomFilter<String> bloomFilter;
    private final MetricsPort metrics;

    private static final Duration BASE_TTL = Duration.ofHours(24);
    private static final long MAX_JITTER_SECONDS = 60;

    public RedisUrlCache(StringRedisTemplate redisTemplate, RedissonClient redisson, MetricsPort metrics) {
        this.redisTemplate = redisTemplate;
        this.redisson = redisson;
        this.metrics = metrics;

        // Caffeine Local Cache: 100 items, 5 seconds TTL
        this.localCache = Caffeine.newBuilder()
                .maximumSize(100)
                .expireAfterWrite(Duration.ofSeconds(5))
                .build();

        // Bloom Filter: Expected 100M elements, 1% false positive probability
        this.bloomFilter = redisson.getBloomFilter("url_shortener:bloom_filter");
        this.bloomFilter.tryInit(100_000_000L, 0.01);
    }

    @Override
    public String get(String id) {
        // 1. Check Local Cache (Hot Keys)
        String localValue = localCache.getIfPresent(id);
        if (localValue != null) {
            return localValue;
        }

        // 2. Check Bloom Filter (Protection against Cache Penetration)
        if (!bloomFilter.contains(id)) {
            metrics.recordBloomFilterRejection();
            return null; // Definitely doesn't exist
        }

        // 3. Check Redis
        String redisValue = redisTemplate.opsForValue().get("url:" + id);

        // Populate Local Cache if found
        if (redisValue != null) {
            localCache.put(id, redisValue);
        }

        return redisValue;
    }

    @Override
    public void put(String id, String originalUrl) {
        // Add to Bloom Filter
        bloomFilter.add(id);

        // Add to Redis with Jitter (Protection against Cache Stampede)
        long jitter = ThreadLocalRandom.current().nextLong(MAX_JITTER_SECONDS);
        Duration ttl = BASE_TTL.plusSeconds(jitter);

        redisTemplate.opsForValue().set("url:" + id, originalUrl, ttl);

        // Add to Local Cache
        localCache.put(id, originalUrl);
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/redis/RangeAwareIdGenerator.java =====

package com.example.urlshortener.infra.adapter.output.redis;

import com.example.urlshortener.core.ports.outgoing.IdGeneratorPort;
import org.hashids.Hashids;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

@Component
@Primary // Make this the default implementation
public class RangeAwareIdGenerator implements IdGeneratorPort {

    private final StringRedisTemplate redis;
    private final Hashids hashids;
    private final AtomicLong currentId = new AtomicLong(0);
    private volatile long maxIdInCurrentRange = 0;
    private static final int RANGE_SIZE = 1000;
    private static final String SEQUENCE_KEY = "global_link_id_seq";

    private final ReentrantLock lock = new ReentrantLock();

    public RangeAwareIdGenerator(StringRedisTemplate redis, Hashids hashids) {
        this.redis = redis;
        this.hashids = hashids;
    }

    @Override
    @io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker(name = "rateLimiterCb", fallbackMethod = "generateIdFallback")
    public String generateId() {
        long nextId = getNextUniqueId();
        return hashids.encode(nextId);
    }

    /**
     * Emergency fallback: generates IDs without Redis using timestamp + thread ID.
     * This ensures the service continues working even if Redis is down.
     */
    public String generateIdFallback(Throwable t) {
        long timestamp = System.currentTimeMillis();
        long threadId = Thread.currentThread().threadId();
        long emergencyId = (timestamp << 20) | (threadId & 0xFFFFF); // Combine timestamp + thread bits
        return hashids.encode(emergencyId);
    }

    private long getNextUniqueId() {
        long next = currentId.incrementAndGet();

        // If local range is exhausted, fetch new block from Redis
        if (next > maxIdInCurrentRange) {
            lock.lock();
            try {
                if (currentId.get() > maxIdInCurrentRange) {
                    // Call Redis INCRBY 1000
                    Long upperLimit = redis.opsForValue().increment(SEQUENCE_KEY, RANGE_SIZE);

                    if (upperLimit == null) {
                        throw new IllegalStateException("Failed to increment sequence in Redis");
                    }

                    maxIdInCurrentRange = upperLimit;
                    currentId.set(upperLimit - RANGE_SIZE + 1);
                    return currentId.get();
                }
            } finally {
                lock.unlock();
            }
            // Simple retry if another thread already updated
            return getNextUniqueId();
        }
        return next;
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/redis/RedisRateLimiterAdapter.java =====

package com.example.urlshortener.infra.adapter.output.redis;

import com.example.urlshortener.core.ports.outgoing.RateLimiterPort;
import org.redisson.api.RAtomicLong;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.time.Duration;

/**
 * Redis based token‑bucket rate limiter. Uses a simple counter per IP address
 * with a TTL equal to the window size. The limit and window are configurable
 * via application.yml (properties `rate-limiter.limit` and
 * `rate-limiter.window`).
 */
@Component
public class RedisRateLimiterAdapter implements RateLimiterPort {
    private final long limit;
    private final Duration window;
    private final RedissonClient redisson;

    public RedisRateLimiterAdapter(
            RedissonClient redisson,
            @Value("${rate-limiter.limit:60}") long limit,
            @Value("${rate-limiter.window:PT1M}") Duration window) {
        this.redisson = redisson;
        this.limit = limit;
        this.window = window;
    }

    @Override
    @io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker(name = "rateLimiterCb", fallbackMethod = "allowRequestOnFailure")
    public boolean isAllowed(String ip) {
        String key = "rl:" + ip;
        RAtomicLong counter = redisson.getAtomicLong(key);
        long current = counter.incrementAndGet();
        if (current == 1) {
            // first request for this window – set expiry
            counter.expire(window);
        }
        return current <= limit;
    }

    public boolean allowRequestOnFailure(String ip, Throwable t) {
        // Fail open: allow request if Redis is down
        // In a real app, you might want to log this error
        return true;
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/analytics/AsyncAnalyticsAdapter.java =====

package com.example.urlshortener.infra.adapter.output.analytics;

import com.example.urlshortener.core.model.ClickEvent;
import com.example.urlshortener.core.ports.outgoing.AnalyticsPort;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

@Component
public class AsyncAnalyticsAdapter implements AnalyticsPort {

    private static final Logger log = LoggerFactory.getLogger(AsyncAnalyticsAdapter.class);
    private final BlockingQueue<ClickEvent> eventQueue;

    public AsyncAnalyticsAdapter() {
        // Capacity of 100k events to handle bursts
        this.eventQueue = new LinkedBlockingQueue<>(100_000);
    }

    @Override
    public void track(ClickEvent event) {
        // Fire-and-forget: Add to queue and return immediately
        // Using offer() to avoid blocking the http thread if queue is full
        if (!eventQueue.offer(event)) {
            log.warn("Analytics queue full! Dropping event for ID: {}", event.shortCode());
        }
    }

    public BlockingQueue<ClickEvent> getQueue() {
        return eventQueue;
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/analytics/ClickBatchWorker.java =====

package com.example.urlshortener.infra.adapter.output.analytics;

import com.example.urlshortener.core.model.ClickEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;

@Component
public class ClickBatchWorker {

    private static final Logger log = LoggerFactory.getLogger(ClickBatchWorker.class);
    private final AsyncAnalyticsAdapter analyticsAdapter;

    // In a real scenario, we would inject a Repository to save these events
    // private final ClickRepository clickRepository;

    public ClickBatchWorker(AsyncAnalyticsAdapter analyticsAdapter) {
        this.analyticsAdapter = analyticsAdapter;
    }

    // Run every 5 seconds
    @Scheduled(fixedRate = 5000)
    public void processBatch() {
        BlockingQueue<ClickEvent> queue = analyticsAdapter.getQueue();
        if (queue.isEmpty()) {
            return;
        }

        List<ClickEvent> batch = new ArrayList<>();
        queue.drainTo(batch, 1000); // Drain up to 1000 events

        if (!batch.isEmpty()) {
            log.info("Processing batch of {} click events...", batch.size());
            // Here we would do a batch insert into Cassandra
            // clickRepository.saveAll(batch);

            // For now, just log to simulate processing
            batch.forEach(e -> log.debug("Processed click for {}", e.shortCode()));
        }
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/persistence/CassandraUrlRepository.java =====

package com.example.urlshortener.infra.adapter.output.persistence;

import com.example.urlshortener.core.model.ShortUrl;
import com.example.urlshortener.core.ports.outgoing.UrlRepositoryPort;
import com.example.urlshortener.infra.adapter.output.persistence.entity.ShortUrlEntity;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

interface SpringDataCassandraUrlRepository extends CrudRepository<ShortUrlEntity, String> {
}

@Repository
public class CassandraUrlRepository implements UrlRepositoryPort {

    private final SpringDataCassandraUrlRepository springDataRepository;

    public CassandraUrlRepository(SpringDataCassandraUrlRepository springDataRepository) {
        this.springDataRepository = springDataRepository;
    }

    @Override
    @io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker(name = "databaseCb")
    public void save(ShortUrl shortUrl) {
        ShortUrlEntity entity = new ShortUrlEntity(shortUrl.id(), shortUrl.originalUrl(), shortUrl.createdAt());
        springDataRepository.save(entity);
    }

    @Override
    @io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker(name = "databaseCb")
    public java.util.Optional<ShortUrl> findById(String id) {
        return springDataRepository.findById(id)
                .map(entity -> new ShortUrl(entity.getId(), entity.getOriginalUrl(), entity.getCreatedAt()));
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/output/persistence/entity/ShortUrlEntity.java =====

package com.example.urlshortener.infra.adapter.output.persistence.entity;

import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.time.LocalDateTime;

@Table("short_urls")
public class ShortUrlEntity {

    @PrimaryKey
    private String id;
    private String originalUrl;
    private LocalDateTime createdAt;

    public ShortUrlEntity() {
    }

    public ShortUrlEntity(String id, String originalUrl, LocalDateTime createdAt) {
        this.id = id;
        this.originalUrl = originalUrl;
        this.createdAt = createdAt;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getOriginalUrl() {
        return originalUrl;
    }

    public void setOriginalUrl(String originalUrl) {
        this.originalUrl = originalUrl;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
}


===== src/main/java/com/example/urlshortener/infra/adapter/input/rest/dto/ShortenRequest.java =====

package com.example.urlshortener.infra.adapter.input.rest.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

public record ShortenRequest(
        @NotBlank(message = "URL cannot be empty") @Pattern(regexp = "^https?://.*", message = "URL must start with http:// or https://") String originalUrl) {
}


===== src/main/java/com/example/urlshortener/infra/adapter/input/rest/dto/ShortenResponse.java =====

package com.example.urlshortener.infra.adapter.input.rest.dto;

public record ShortenResponse(String id, String shortUrl) {
}


===== src/main/java/com/example/urlshortener/infra/adapter/input/rest/UrlController.java =====

package com.example.urlshortener.infra.adapter.input.rest;

import com.example.urlshortener.core.model.ShortUrl;
import com.example.urlshortener.core.ports.incoming.ShortenUrlUseCase;
import com.example.urlshortener.core.ports.incoming.GetUrlUseCase;
import com.example.urlshortener.core.ports.outgoing.AnalyticsPort;
import com.example.urlshortener.core.ports.outgoing.RateLimiterPort;
import com.example.urlshortener.infra.adapter.input.rest.dto.ShortenRequest;
import com.example.urlshortener.infra.adapter.input.rest.dto.ShortenResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Tag(name = "URL Shortener", description = "High-performance URL shortening and redirection API")
public class UrlController {

        private final ShortenUrlUseCase shortenUrlUseCase;
        private final GetUrlUseCase getUrlUseCase;
        private final AnalyticsPort analyticsPort;
        private final RateLimiterPort rateLimiter;
        private final HttpServletRequest request;

        public UrlController(ShortenUrlUseCase shortenUrlUseCase,
                        GetUrlUseCase getUrlUseCase,
                        AnalyticsPort analyticsPort,
                        RateLimiterPort rateLimiter,
                        HttpServletRequest request) {
                this.shortenUrlUseCase = shortenUrlUseCase;
                this.getUrlUseCase = getUrlUseCase;
                this.analyticsPort = analyticsPort;
                this.rateLimiter = rateLimiter;
                this.request = request;
        }

        @PostMapping("/api/v1/urls")
        @Operation(summary = "Shorten a URL", description = "Creates a short URL code for the provided long URL. Uses Hashids encoding with Redis-backed ID generation (1000 IDs batched in memory).")
        @ApiResponses(value = {
                        @ApiResponse(responseCode = "200", description = "URL successfully shortened", content = @Content(schema = @Schema(implementation = ShortenResponse.class))),
                        @ApiResponse(responseCode = "400", description = "Invalid URL format", content = @Content),
                        @ApiResponse(responseCode = "429", description = "Rate limit exceeded", content = @Content)
        })
        public ResponseEntity<ShortenResponse> shorten(
                        @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "URL to be shortened", required = true, content = @Content(schema = @Schema(implementation = ShortenRequest.class))) @jakarta.validation.Valid @RequestBody ShortenRequest request) {
                String clientIp = this.request.getRemoteAddr();
                if (!rateLimiter.isAllowed(clientIp)) {
                        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).build();
                }
                ShortUrl shortUrl = shortenUrlUseCase.shorten(request.originalUrl());
                String baseUrl = org.springframework.web.servlet.support.ServletUriComponentsBuilder
                                .fromCurrentContextPath().build().toUriString();
                return ResponseEntity.ok(new ShortenResponse(shortUrl.id(), baseUrl + "/" + shortUrl.id()));
        }

        @GetMapping("/{id}")
        @Operation(summary = "Redirect to original URL", description = "Retrieves the original URL and redirects (HTTP 302). Uses multi-level caching: Caffeine (L1, 5s) → Redis (L2, 24h+jitter) → Cassandra. Click events are tracked asynchronously without blocking the redirect.")
        @ApiResponses(value = {
                        @ApiResponse(responseCode = "302", description = "Redirect to original URL"),
                        @ApiResponse(responseCode = "404", description = "Short URL not found", content = @Content)
        })
        public ResponseEntity<Void> redirect(
                        @Parameter(description = "Short URL code (e.g., vE1GpYK)", required = true, example = "vE1GpYK") @PathVariable String id,
                        HttpServletRequest request) {
                String originalUrl = getUrlUseCase.getOriginalUrl(id);
                analyticsPort.track(new com.example.urlshortener.core.model.ClickEvent(
                                id,
                                java.time.LocalDateTime.now(),
                                request.getHeader("User-Agent"),
                                request.getRemoteAddr()));
                return ResponseEntity.status(HttpStatus.FOUND).location(java.net.URI.create(originalUrl)).build();
        }
}


===== src/main/java/com/example/urlshortener/infra/adapter/input/rest/advice/GlobalExceptionHandler.java =====

package com.example.urlshortener.infra.adapter.input.rest.advice;

import com.example.urlshortener.core.exception.UrlNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(UrlNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUrlNotFound(UrlNotFoundException ex) {
        log.warn("URL not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                "URL Not Found",
                ex.getMessage(),
                LocalDateTime.now());

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException ex) {
        log.warn("Invalid argument: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Invalid Request",
                ex.getMessage(),
                LocalDateTime.now());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        log.warn("Validation failed: {}", ex.getMessage());

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ValidationErrorResponse errorResponse = new ValidationErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Validation Failed",
                "Request validation failed",
                LocalDateTime.now(),
                errors);

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorResponse> handleTypeMismatch(MethodArgumentTypeMismatchException ex) {
        log.warn("Type mismatch: {}", ex.getMessage());

        String message = String.format("Invalid value '%s' for parameter '%s'",
                ex.getValue(), ex.getName());

        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Invalid Parameter Type",
                message,
                LocalDateTime.now());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred", ex);

        ErrorResponse error = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "An unexpected error occurred. Please try again later.",
                LocalDateTime.now());

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    // Error response DTOs
    public record ErrorResponse(
            int status,
            String error,
            String message,
            LocalDateTime timestamp) {
    }

    public record ValidationErrorResponse(
            int status,
            String error,
            String message,
            LocalDateTime timestamp,
            Map<String, String> validationErrors) {
    }
}


===== src/main/java/com/example/urlshortener/core/service/UrlShortenerService.java =====

package com.example.urlshortener.core.service;

import com.example.urlshortener.core.model.ShortUrl;
import com.example.urlshortener.core.model.Url;
import com.example.urlshortener.core.ports.incoming.GetUrlUseCase;
import com.example.urlshortener.core.ports.incoming.ShortenUrlUseCase;
import com.example.urlshortener.core.ports.outgoing.IdGeneratorPort;
import com.example.urlshortener.core.ports.outgoing.MetricsPort;
import com.example.urlshortener.core.ports.outgoing.UrlCachePort;
import com.example.urlshortener.core.ports.outgoing.UrlRepositoryPort;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.Objects;

public class UrlShortenerService implements ShortenUrlUseCase, GetUrlUseCase {

    private static final Logger log = LoggerFactory.getLogger(UrlShortenerService.class);

    // Log message constants
    private static final String LOG_CACHE_HIT = "Cache Hit for ID: {}";
    private static final String LOG_CACHE_MISS = "Cache Miss for ID: {}. Fetching from DB...";

    private final UrlRepositoryPort urlRepository;
    private final IdGeneratorPort idGenerator;
    private final UrlCachePort urlCache;
    private final MetricsPort metrics;

    public UrlShortenerService(UrlRepositoryPort urlRepository, IdGeneratorPort idGenerator,
            UrlCachePort urlCache, MetricsPort metrics) {
        this.urlRepository = urlRepository;
        this.idGenerator = idGenerator;
        this.urlCache = urlCache;
        this.metrics = metrics;
    }

    @Override
    public ShortUrl shorten(String originalUrl) {
        // Input validation
        Objects.requireNonNull(originalUrl, "URL cannot be null");

        // Validate URL format using Value Object
        Url validatedUrl = new Url(originalUrl);

        String id = idGenerator.generateId();
        ShortUrl shortUrl = new ShortUrl(id, validatedUrl.value(), LocalDateTime.now());
        urlRepository.save(shortUrl);

        // Record metric
        metrics.recordUrlShortened();

        return shortUrl;
    }

    @Override
    public String getOriginalUrl(String id) {
        // Input validation
        Objects.requireNonNull(id, "ID cannot be null");
        if (id.isBlank()) {
            throw new IllegalArgumentException("ID cannot be empty");
        }

        // 1. Check Cache
        String cachedUrl = urlCache.get(id);
        if (cachedUrl != null) {
            log.info(LOG_CACHE_HIT, id);
            metrics.recordCacheHit();
            return cachedUrl;
        }

        // 2. Check Database
        log.info(LOG_CACHE_MISS, id);
        metrics.recordCacheMiss();

        return urlRepository.findById(id)
                .map(shortUrl -> {
                    // 3. Populate Cache
                    urlCache.put(id, shortUrl.originalUrl());
                    return shortUrl.originalUrl();
                })
                .orElseThrow(() -> new com.example.urlshortener.core.exception.UrlNotFoundException(id));
    }
}


===== src/main/java/com/example/urlshortener/core/model/Url.java =====

package com.example.urlshortener.core.model;

import java.util.Objects;

/**
 * Value Object representing a URL with validation.
 * Immutable and validates URL format on construction.
 */
public record Url(String value) {

    private static final String URL_PATTERN = "^https?://.*";

    public Url {
        Objects.requireNonNull(value, "URL cannot be null");

        // Trim whitespace FIRST
        value = value.trim();

        if (value.isBlank()) {
            throw new IllegalArgumentException("URL cannot be empty");
        }

        if (!value.matches(URL_PATTERN)) {
            throw new IllegalArgumentException(
                    "Invalid URL format. Must start with http:// or https://");
        }
    }

    @Override
    public String toString() {
        return value;
    }
}


===== src/main/java/com/example/urlshortener/core/model/ShortUrl.java =====

package com.example.urlshortener.core.model;

import java.time.LocalDateTime;

public record ShortUrl(
    String id,
    String originalUrl,
    LocalDateTime createdAt
) {}


===== src/main/java/com/example/urlshortener/core/model/ClickEvent.java =====

package com.example.urlshortener.core.model;

import java.time.LocalDateTime;

public record ClickEvent(
        String shortCode,
        LocalDateTime timestamp,
        String userAgent,
        String ip) {
}


===== src/main/java/com/example/urlshortener/core/exception/UrlNotFoundException.java =====

package com.example.urlshortener.core.exception;

public class UrlNotFoundException extends RuntimeException {
    public UrlNotFoundException(String id) {
        super("URL not found for ID: " + id);
    }
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/UrlCachePort.java =====

package com.example.urlshortener.core.ports.outgoing;

public interface UrlCachePort {
    String get(String id);

    void put(String id, String originalUrl);
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/RateLimiterPort.java =====

package com.example.urlshortener.core.ports.outgoing;

/**
 * Port for per‑IP rate limiting.
 * Implementations decide how to track request counts (e.g., Redis token
 * bucket).
 */
public interface RateLimiterPort {
    /**
     * Returns {@code true} if the request from the given IP address is allowed
     * under the configured rate limit, {@code false} otherwise.
     */
    boolean isAllowed(String ip);
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/AnalyticsPort.java =====

package com.example.urlshortener.core.ports.outgoing;

import com.example.urlshortener.core.model.ClickEvent;

public interface AnalyticsPort {
    void track(ClickEvent event);
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/MetricsPort.java =====

package com.example.urlshortener.core.ports.outgoing;

/**
 * Port for recording application metrics.
 * Allows the core domain to track business events without depending on
 * infrastructure.
 */
public interface MetricsPort {

    void recordUrlShortened();

    void recordCacheHit();

    void recordCacheMiss();

    void recordBloomFilterRejection();
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/UrlRepositoryPort.java =====

package com.example.urlshortener.core.ports.outgoing;

import com.example.urlshortener.core.model.ShortUrl;

public interface UrlRepositoryPort {
    void save(ShortUrl shortUrl);

    java.util.Optional<ShortUrl> findById(String id);
}


===== src/main/java/com/example/urlshortener/core/ports/outgoing/IdGeneratorPort.java =====

package com.example.urlshortener.core.ports.outgoing;

public interface IdGeneratorPort {
    String generateId();
}


===== src/main/java/com/example/urlshortener/core/ports/incoming/GetUrlUseCase.java =====

package com.example.urlshortener.core.ports.incoming;

public interface GetUrlUseCase {
    String getOriginalUrl(String id);
}


===== src/main/java/com/example/urlshortener/core/ports/incoming/ShortenUrlUseCase.java =====

package com.example.urlshortener.core.ports.incoming;

import com.example.urlshortener.core.model.ShortUrl;

public interface ShortenUrlUseCase {
    ShortUrl shorten(String originalUrl);
}


===== src/main/resources/application.yml =====

server:
  undertow:
    threads:
      io: 16           # I/O threads (Usually cores * 2)
      worker: 200      # Worker threads (Virtual threads handle the heavy load)
    buffer-size: 1024  # Direct buffer optimization
    direct-buffers: true

spring:
  application:
    name: url-shortener-native
  threads:
    virtual:
      enabled: true  # Enables Virtual Threads across the container (Undertow)

app:
  shortener:
    salt: "my-secret-salt-change-me-in-prod" # Should be an env var in production

  # Optimized Configuration for Cassandra and Redis
  cassandra:
    keyspace-name: url_shortener
    local-datacenter: datacenter1
    connection:
      connect-timeout: 2s
      init-query-timeout: 2s
    schema-action: create-if-not-exists
  
  data:
    redis:
      host: localhost
      port: 6379
      timeout: 500ms

management:
  endpoints:
    web:
      exposure:
        include: health, info, metrics, prometheus, circuitbreakers
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
      show-components: always
  health:
    circuitbreakers:
      enabled: true

rate-limiter:
  limit: 60
  window: PT1M

resilience4j:
  circuitbreaker:
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
    instances:
      rateLimiterCb:
        baseConfig: default
        failureRateThreshold: 40
        waitDurationInOpenState: 10s
      databaseCb:
        baseConfig: default
        failureRateThreshold: 50
        waitDurationInOpenState: 20s
